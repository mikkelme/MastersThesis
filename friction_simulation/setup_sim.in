#####################################
# Setup simulation from read_data   #
# config file or from restart file. # 
#####################################


# --- Default settings --- #
variable rupture_detection index 1 # Whether to run rupture detection

# SWITCH: read_data || read_restart
variable restart_file index None
variable readable equal is_file(${restart_file})
if ${readable} then "jump SELF setup_from_restart_file"

####################################
### --- Setup from read_data --- ###
####################################
print "Setting up simulation from read_data: ${config_data}.txt"

# --- Basics --- # 
units metal
newton on #newtons 3rd law for pairs
boundary p p m  
atom_style bond



# --- Read files --- #
read_data ${root}/${config_data}.txt extra/atom/types 1 extra/bond/types 1 extra/bond/per/atom 10 
include ${root}/${config_data}_info.in                   # import variables

bond_style zero
bond_coeff *


# --- Masses --- #            
mass 1 12.0107          # C
mass 2 28.0855          # Si
mass 3 1.0              # Virtuel atom


# --- Regions and groups --- #
variable eps equal 0.1 # small number to ensure all atoms is inside interval

group full_sheet type 1
group  substrate type 2


# Computes for sheet and substrate position 
compute full_sheet_xmin full_sheet reduce min x  
compute full_sheet_xmax full_sheet reduce max x  
compute full_sheet_ymin full_sheet reduce min y  
compute full_sheet_ymax full_sheet reduce max y  
compute full_sheet_z full_sheet reduce ave z 
compute substrate_zmin substrate reduce min z  
compute substrate_zmax substrate reduce max z  
thermo_style custom c_full_sheet_xmin c_full_sheet_xmax c_full_sheet_ymin c_full_sheet_ymax c_full_sheet_z c_substrate_zmin c_substrate_zmax 
run 0


if "!$(count(substrate)) > 0" then "variable sheet_substrate_border string INF" &
else "variable sheet_substrate_border equal $((c_substrate_zmax + c_full_sheet_z)/2)"

## Sheet 
region sheet_region block INF INF $(v_pullblock_yhi+v_eps) $(v_pullblock_ylo-v_eps) ${sheet_substrate_border} INF
group  sheet region sheet_region

## Pullblocks
region PB_ylow_region block INF INF INF $(v_pullblock_yhi+v_eps) ${sheet_substrate_border} INF
region PB_ylow_rigid_region block INF INF INF $((c_full_sheet_ymin + v_pullblock_yhi)/2) ${sheet_substrate_border} INF 
region PB_yhigh_region block INF INF $(v_pullblock_ylo-v_eps) INF ${sheet_substrate_border} INF
region PB_yhigh_rigid_region block INF INF $((c_full_sheet_ymax + v_pullblock_ylo)/2) INF ${sheet_substrate_border} INF 

# PB ylow
group PB_ylow region PB_ylow_region
group PB_ylow_rigid region PB_ylow_rigid_region
group PB_ylow_NVT subtract PB_ylow PB_ylow_rigid

# PB yhigh
group PB_yhigh region PB_yhigh_region
group PB_yhigh_rigid region PB_yhigh_rigid_region
group PB_yhigh_NVT subtract PB_yhigh PB_yhigh_rigid

# PB unions
group PB_tot union PB_ylow PB_yhigh
group PB_tot_rigid union PB_ylow_rigid PB_yhigh_rigid




#######################################
# Build Substrate if not in read file #
#######################################

# Check if substrate is included in the file
if "$(count(substrate)) > 0" then "jump SELF substrate_built"

# --- Build parameters --- #
variable a_Si equal 5.430953   # lattice spacing [Å]
variable substrate_x_margin equal 20 # margin between sheet and substrate edge in x-direction [Å]
variable substrate_y_margin equal 15 # margin between sheet and substrate edge y-direction [Å]
# variable sheet_substrate_dis equal 2.8  # Distance between shhet and substrate top
variable sheet_substrate_dis equal 3.0  # Distance between shhet and substrate top

# Number of layers for various substrate sections
variable substrate_freeze_layers equal 3 # [num layers]
variable substrate_NVT_layers equal 3 # [num layers]
variable substrate_contact_layers equal 3 # [num layers]

# --- Get measurements --- #
# Calculate sheet center and length of the sheet
variable full_sheet_Lx equal $(c_full_sheet_xmax - c_full_sheet_xmin) 
variable full_sheet_Ly equal $(c_full_sheet_ymax - c_full_sheet_ymin) 
variable full_sheet_xcenter equal $((c_full_sheet_xmin + c_full_sheet_xmax)/2)
variable full_sheet_ycenter equal $((c_full_sheet_ymin + c_full_sheet_ymax)/2)

# Minimum length required for substrate in x-y directions
variable xmin equal $(v_full_sheet_Lx + v_substrate_x_margin)  # [Å]
variable ymin equal $(v_full_sheet_Ly*(1+v_SMAX) + v_substrate_y_margin) # [Å]
variable xlen equal $(ceil((v_xmin + 1/4*v_a_Si)/v_a_Si))  # [a_Si] 
variable ylen equal $(ceil((v_ymin + 1/4*v_a_Si)/v_a_Si))  # [a_Si] 

# Respective section depths
variable substrate_freeze_depth equal $(v_substrate_freeze_layers * v_a_Si/4)
variable substrate_contact_depth equal $(v_substrate_contact_layers * v_a_Si/4)

# Depth of substrate 
variable num_substrate_layers equal $(v_substrate_freeze_layers + v_substrate_NVT_layers + v_substrate_contact_layers)
variable zlen equal $(v_num_substrate_layers/4 - v_eps) # [a_Si]

# --- Build substrate --- #
lattice diamond ${a_Si} 
region	substrate_region block 0 ${xlen} 0 ${ylen} 0 ${zlen} 

# Reshape simulation box and fill with atoms
change_box all x final 0 ${xlen} 
change_box all y final 0 ${ylen} 
change_box all z final 0 ${zlen} 
create_atoms 2 region substrate_region

# Readjust to align sheet with substrate
displace_atoms full_sheet move $(v_a_Si*v_xlen/2 - v_full_sheet_xcenter) $(v_a_Si*v_ylen/2 - v_full_sheet_ycenter) $(v_a_Si*(v_zlen+v_eps-1/4) + v_sheet_substrate_dis - c_full_sheet_z) units box


# Clean 
variable full_sheet_Lx delete
variable full_sheet_Ly delete
variable full_sheet_xcenter delete
variable full_sheet_ycenter delete
uncompute full_sheet_xmin 
uncompute full_sheet_xmax 

# Update substrate compute
group substrate type 2
uncompute substrate_zmin 
uncompute substrate_zmax 
compute substrate_zmin substrate reduce min z  
compute substrate_zmax substrate reduce max z  
thermo_style custom c_substrate_zmin c_substrate_zmax 
run 0

label substrate_built
# write_data what_is_going_on.txt
########################################################################



# --- Continue regions and groups setup ---#
## Substrate
region substrate_freeze_region block INF INF INF INF INF $(v_substrate_freeze_depth - c_substrate_zmin - v_eps) units box
region substrate_freeze_and_NVT_region block INF INF INF INF INF $(v_eps + c_substrate_zmax - v_substrate_contact_depth) units box
region substrate_contact_region block INF INF INF INF $(v_eps + c_substrate_zmax - v_substrate_contact_depth) $(c_substrate_zmax + v_eps) units box

group substrate_freeze region substrate_freeze_region
group substrate_freeze_and_NVT region substrate_freeze_and_NVT_region
group substrate_contact region substrate_contact_region
group substrate_top subtract substrate substrate_freeze_and_NVT
group substrate_NVT subtract substrate_freeze_and_NVT substrate_freeze


## Moving atoms
group NVE_atoms subtract all substrate_freeze 
group NVT_atoms union PB_ylow_NVT PB_yhigh_NVT substrate_NVT
group free_atoms subtract all PB_tot substrate_freeze 
group non_drag_atoms subtract all PB_tot_rigid substrate_freeze 

# Set velocity 
velocity free_atoms create 0 5432373 dist gaussian


uncompute full_sheet_ymin
uncompute full_sheet_ymax
uncompute full_sheet_z 
uncompute substrate_zmin 
uncompute substrate_zmax

thermo_style custom step
run 0
# JUMP
jump SELF common_settings 


#######################################
### --- Setup from read_restart --- ###
#######################################
label setup_from_restart_file
print "Setting up simulation from read_restart: ${restart_file}"

# --- Read restart file --- #
read_restart ${restart_file}
compute get_S0 S0_info reduce sum y # Retrieve information about S0 via type 3 tmp atom
compute get_FN_max S0_info reduce sum x # Retrieve information about FN_max via type 3 tmp atom


###############################
### --- Common settings --- ###
###############################
label common_settings
neighbor            0.5 bin
neigh_modify        delay 0 every 1 one 10000


# ------- SI SUBSTRATE TERSOFF ------- # Nature: The evolving quality of frictional contact with graphene
# Potentials: C-C: Tersoff, C-Si: LJ, Si-Si: SW
variable LJ_sigma equal 3.0
pair_style hybrid tersoff lj/cut $(v_LJ_sigma*2.5) sw 
pair_coeff * * tersoff ${root}/C.tersoff C NULL NULL   # Sheet C-C
pair_coeff 1 2 lj/cut 0.0092 ${LJ_sigma}               # Interaction C-Si 
pair_coeff * * sw ${root}/si.sw NULL Si NULL           # Substrate Si-Si
pair_coeff * 3  lj/cut 0.0 0.0 


# Create bonds for rupture detection
variable bond_rmax_create equal 1.5 # Max length of created bonds
variable bond_rbreak equal 4.0      # Rupture length for bonds


if "${rupture_detection} && !${readable}" then &
"create_bonds many sheet sheet 1 0.0 ${bond_rmax_create}" &
"special_bonds lj 1 1 1" & 

if "${rupture_detection}" then &
"compute         bdist sheet bond/local dist" &
"compute         bmax sheet reduce max c_bdist" &
"variable        is_ruptured equal c_bmax>v_bond_rbreak" &
"fix rupture_detector sheet halt 1 v_is_ruptured != 0 error continue" &
else &
"variable is_ruptured equal 0"


variable LJ_equil equal $(2^(1/6) * v_LJ_sigma)
# variable contact_cut_off equal $(v_LJ_equil*1.1)
variable contact_cut_off equal 4.0

timestep $(v_dt)
variable damp equal 1.0 # ps                        
fix nve NVE_atoms nve # (microcanonical) 
fix nvt NVT_atoms langevin ${T} ${T} ${damp} 48279 # (canonical)

fix 2 all balance 1000 1.05 shift xy 10 1.05 # balance number of particles computed on each processor 
fix PB_ave PB_tot_rigid aveforce NULL NULL 0 # Average z-force

# --- Convertion: SI to metal --- #
variable N_to_eV_over_ang equal 6.24150907e8    # force: N -> eV/Å
variable m_to_ang equal 1e10                    # distance: m -> Å
variable s_to_ps equal 1e12                     # time: s -> ps


# ---------- Computes ---------- #
variable Nevery equal 1     # use input values every this many time steps
variable Nrepeat equal 100  # number of times to use input values for calculating averages
variable Nfreq equal 100    # calculate averages every this many time steps

## - Sheet - ##
# Full sheet
compute sheet_COM full_sheet com            # Center of mass
compute sheet_fz full_sheet reduce ave fz   # Average z-force
compute bond_coord full_sheet coord/atom cutoff ${contact_cut_off} group substrate_contact
fix full_sheet_bond_hist full_sheet ave/histo 1 1 1 -0.5 1.5 2 c_bond_coord mode vector beyond end
variable full_sheet_bond_pct equal f_full_sheet_bond_hist[2][3]

# Inner sheet 
compute sheet_fx sheet reduce sum fx        # Total force x
compute sheet_fy sheet reduce sum fy        # Total force y

compute sheet_ymin sheet reduce min y   
compute sheet_ymax sheet reduce max y 

# compute coord sheet coord/atom cutoff 2.7   # Coordination number
# compute sheet_stress sheet stress/atom NULL      # stress field
# variable stress_atom atom sqrt(c_sheet_stress[1]*c_sheet_stress[1]+c_sheet_stress[2]*c_sheet_stress[2]+c_sheet_stress[3]*c_sheet_stress[3]) # Stress norm (xx, yy, zz)


# # Num clusters in sheet
# if "${rupture_detection}" then & 
# "compute cluster_atom full_sheet cluster/atom 4.0" &
# "compute Ncluster full_sheet chunk/atom c_cluster_atom compress yes" 
# variable is_ruptured equal 0 # Default value


fix sheet_bond_hist sheet ave/histo 1 1 1 -0.5 1.5 2 c_bond_coord mode vector beyond end
variable sheet_bond_pct equal f_sheet_bond_hist[2][3]


## - Pullblocks - ##
compute PB_ylow_rigid_ymax PB_ylow_rigid reduce max y   # Lower y-limit for sheet
compute PB_yhigh_rigid_ymin PB_yhigh_rigid reduce min y # Upper y-limit for sheet
compute PB_tot_COM PB_tot com                           # Center of mass


## -- Substrate -- ##
compute substrate_zhigh substrate reduce max z # Max z-val of substrate

## Interactions ##
compute Ff substrate group/group full_sheet # friction forces
compute Ff_sheet substrate group/group sheet # friction forces
compute Ff_PB substrate group/group PB_tot # friction forces

## Temperature of free atoms ##
compute sheetTemp sheet temp
compute subtopTemp substrate_top temp


## - Activate computes - ## 
thermo_style custom c_PB_yhigh_rigid_ymin c_PB_ylow_rigid_ymax c_sheet_COM[1] c_PB_tot_COM[1]
run 0 # activate compute



# ---------- Derived variables ---------- #
## -- Seperation -- ##
variable sub_sheet_seperation equal c_sheet_COM[3]-c_substrate_zhigh  # seperation between substrate max and COM of sheet

## -- Force on PB -- ##
variable move_force_x equal c_sheet_fx+c_Ff[1]
variable move_force_y equal c_sheet_fy+c_Ff[2]
variable move_force_xy_norm equal sqrt(v_move_force_x^2+v_move_force_x^2)  

## -- Stretch -- ##
variable S0 equal c_PB_yhigh_rigid_ymin-c_PB_ylow_rigid_ymax    # start len of inner sheet 


# Restart file: Get S0 stored in type 3 tmp atom
if ${readable} then "thermo_style custom c_get_S0 c_get_FN_max c_PB_yhigh_rigid_ymin c_PB_ylow_rigid_ymax" &
"run 0" &
"variable S0 equal $(c_get_S0)" &
"variable FN_max equal $(c_get_FN_max*1e2)" &
"delete_atoms group S0_info"


variable S_len equal c_PB_yhigh_rigid_ymin-c_PB_ylow_rigid_ymax # Updated len of inner sheet
variable stretch_pct equal (v_S_len-v_S0)/v_S0  # Updated stretch pct
variable stretch_speed equal v_stretch_speed_pct*v_S0 

## -- Drag -- ##
variable dir_norm equal $(sqrt(v_drag_dir_x^2+v_drag_dir_y^2))

# # RDF
# compute myRDF sheet rdf 1000 1 1 # cutoff 8.65 
# fix tmp all ave/time 100 1 100 c_myRDF[*] file rdf.txt mode vector
# run 100
# quit


# ---------- Output ---------- #
variable dump_freq index 1000
variable thermo index 1000
thermo $(v_thermo)

if "${dump_freq} == 0" then "jump SELF skip_dump"

dump 1 all custom $(v_dump_freq) system_${out_ext}.data id type x y z vx vy vz c_bond_coord
dump 2 full_sheet custom $(v_dump_freq) full_sheet_${out_ext}.data id type x y z vx vy vz c_bond_coord
label skip_dump

# fix coord_out sheet ave/histo ${Nevery} ${Nrepeat} ${Nfreq} -0.5 5.5 6 c_coord mode vector file sheet_${out_ext}_chist.txt
# fix contact_bonds full_sheet ave/time ${Nevery} ${Nrepeat} ${Nfreq} v_sheet_bond_pct v_full_sheet_bond_pct file bond_pct.txt # For presentation purposes


# Visualize groups: Freeze/Semifreeze, NVT, Only NVE
#########################################################################################################
# group pure_NVE subtract NVE_atoms PB_tot NVT_atoms                                                      #
# group locked subtract all NVT_atoms pure_NVE                                                            #
# dump view1 NVT_atoms custom $(v_dump_freq) NVT_atoms.data id type x y z                                 #
# dump view2 pure_NVE custom $(v_dump_freq) pure_NVE.data id type x y z                                   #
# dump view3 locked custom $(v_dump_freq) locked.data id type x y z                                       #
# run 1
# quit
########################################################################################################


# ---------- Print procedure schedule ---------- #
# Timestamps

variable relax_steps equal $(floor(v_relax_time/dt))
variable stretch_steps equal $(floor(v_SMAX/v_stretch_speed_pct/dt))
variable pause1_steps equal $(floor(v_pause_time1/dt))
variable pause2_steps equal $(floor(v_pause_time2/dt))
variable drag_steps equal $(floor(v_drag_length/v_drag_speed/dt))


# Might get chancged if run_rupture_test is on <------------ ###
# Print
print "--------------------"
print "------SCHEDULE------"
print ""
print "--> Relax (step 0, 0 ps)"
print "Time: $(v_relax_steps) steps = $(v_relax_steps*dt) ps" 
print ""
print "--> Stretch sheet (step $(v_relax_steps), $(v_relax_steps*dt) ps)"
print "Amount: $(v_SMAX) % = $(v_SMAX*v_S_len) ang "
print "Speed: $(v_stretch_speed_pct) %/ps = $(v_stretch_speed) ang/ps"
print "Time:  $(v_stretch_steps) steps = $(v_stretch_steps*dt) ps"
print ""
print "--> Pause 1 (step $(v_relax_steps+v_stretch_steps), $((v_relax_steps+v_stretch_steps)*dt) ps)"
print "Time: $(v_pause1_steps) steps = $(v_pause1_steps*dt) ps"
print ""
print "--> Apply normal force (step $(v_relax_steps+v_stretch_steps+v_pause1_steps), $((v_relax_steps+v_stretch_steps+v_pause1_steps)*dt) ps)"
print "Amount: $(v_F_N/v_N_to_eV_over_ang*1e9) nN/m = $(v_F_N) eV/ang"
print ""
print "--> Pause 2 (step $(v_relax_steps+v_stretch_steps+v_pause1_steps), $((v_relax_steps+v_stretch_steps+v_pause1_steps)*dt) ps)"
print "Time: $(v_pause2_steps) steps = $(v_pause2_steps*dt) ps"
print ""
print "--> Drag sheet (step $(v_relax_steps+v_stretch_steps+v_pause1_steps+v_pause2_steps), $((v_relax_steps+v_stretch_steps+v_pause1_steps+v_pause2_steps)*dt) ps)"
print "Length: $(v_drag_length) ang"
print "Speed: $(v_drag_speed*v_s_to_ps/v_m_to_ang) m/s = $(v_drag_speed) ang/ps "
print "Spring constant: $(v_K*v_m_to_ang/v_N_to_eV_over_ang) N/m = $(v_K) eV/ang^2"
print "Time: $(v_drag_steps)  = $(v_drag_steps*dt) ps"
print ""
print "--> END (step $(v_relax_steps+v_stretch_steps+v_pause1_steps+v_pause2_steps+v_drag_steps), $((v_relax_steps+v_stretch_steps+v_pause1_steps+v_pause2_steps+v_drag_steps)*dt) ps)"
print "--------------------"
print "--------------------"
print ""




# Clean up
uncompute sheet_ymin
uncompute sheet_ymax


